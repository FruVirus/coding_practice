"""
8.4 Bucket sort
===============

Bucket sort assumes that the input is drawn from a uniform distribution and has an
average-case running time of O(n). Whereas counting sort assumes that the input consists
of integers in a small range, bucket sort assumes that the input is generated by a
random process that distributes elements uniformly and independently over the interval
[0, 1).

Bucket sort divides the interval [0, 1) into n equal-sized sub-intervals, or buckets,
and then distributes the n input numbers into the buckets. Since the inputs are
uniformly and independently distributed over [0, 1), we do not expect many numbers to
fall into each bucket. To produce the output, we simply sort the numbers in each bucket
and then go through the buckets in order, listing the elements in each.

NB: Counting sort cannot be used here since we use the keys as indices in counting sort.
In bucket sort, the keys are floating point numbers.

Complexity
==========

Time
----

bucket_sort(): O(n)/O(n^2) average/worst case using insertion sort. O(n * lg n) worst
case if an optimal comparison sort is used.

Space
-----

bucket_sort(): O(n) for the B array of buckets.
"""

# Repository Library
from src.clrs.sorting_and_order_statistics.sorting.comparison_sorting.merge_sort import (  # noqa: E501
    merge_sort,
)


def bucket_sort(a):
    n, x = len(a), []
    b = [[] for _ in range(n)]
    for i in range(n):
        b[int(n * a[i])].append(a[i])
    for i in b:
        if i:
            x.extend(merge_sort(i))
    return x
