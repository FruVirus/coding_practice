"""
Overview
========

Bucket sort assumes that the input is drawn from a uniform distribution and has an
average-case running time of O(n). Whereas counting sort assumes that the input consists
of integers in a small range, bucket sort assumes that the input is generated by a
random process that distributes elements uniformly and independently over the interval
[0, 1).

Bucket sort divides the interval [0, 1) into n equal-sized sub-intervals, or buckets,
and then distributes the n input numbers into the buckets. Since the inputs are
uniformly and independently distributed over [0, 1), we do not expect many numbers to
fall into each bucket. To produce the output, we simply sort the numbers in each bucket
and then go through the buckets in order, list the elements in each.

Bucket sort uses insertion sort. Thus, the complexity of bucket sort is determined by
the complexity of the n calls to insertion sort.

Complexity
==========

O(n) average case running time
"""

# Repository Library
from src.clrs.sorting_and_order_statistics.comparison_sorting.insertion_sort import (
    insertion_sort,
)


def bucket_sort(a):
    n, largest = len(a), max(a)
    b = [[] for _ in range(n)]
    size = largest // n + (largest % n > 0)
    for i in range(n):
        b[int(a[i] / size)].append(a[i])
    x = []
    for i in range(n):
        if b[i]:
            insertion_sort(b[i])
            x.extend(b[i])
    return x
